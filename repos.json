[{"url": "https://github.com/OCR-D/ocrd_calamari", "org_plus_name": "OCR-D/ocrd_calamari", "name": "ocrd_calamari", "files": {"ocrd-tool.json": "{\n  \"git_url\": \"https://github.com/kba/ocrd_calamari\",\n  \"version\": \"0.0.1\",\n  \"tools\": {\n    \"ocrd-calamari-recognize\": {\n      \"executable\": \"ocrd-calamari-recognize\",\n      \"categories\": [\n        \"Text recognition and optimization\"\n      ],\n      \"steps\": [\n        \"recognition/text-recognition\"\n      ],\n      \"description\": \"Recognize lines with Calamari\",\n      \"input_file_grp\": [\n        \"OCR-D-SEG-LINE\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-OCR-CALAMARI\"\n      ],\n      \"parameters\": {\n        \"checkpoint\": {\"type\": \"string\", \"format\": \"file\", \"cacheable\": true},\n        \"voter\": {\"type\": \"string\", \"default\": \"confidence_voter_default_ctc\"}\n      }\n    }\n  }\n}\n", "Dockerfile": null, "README.md": "# ocrd_calamari\n\nRecognize text using [Calamari OCR](https://github.com/Calamari-OCR/calamari).\n\n## Introduction\n\nThis offers a OCR-D compliant workspace processor for some of the functionality of Calamari OCR.\n\nThis processor only operates on the text line level and so needs a line segmentation (and by extension a binarized \nimage) as its input.\n\n## Installation\n\n### From PyPI\n\n:construction: :construction: :construction: :construction: :construction: :construction: :construction:\n\n```\npip install ocrd_calamari\n```\n\n### From Repo\n\n```sh\npip install .\n```\n\nTo install the calamari with the GPU version of Tensorflow:\n\n```sh\npip install 'calamari-ocr[tf_cpu]'\npip install .\n```\n\n## Example Usage\n\n~~~\nocrd-calamari-recognize -p test-parameters.json -m mets.xml -I OCR-D-SEG-LINE -O OCR-D-OCR-CALAMARI\n~~~\n\nWith `test-parameters.json`:\n~~~\n{\n    \"checkpoint\": \"/path/to/some/trained/models/*.ckpt.json\"\n}\n~~~\n\nTODO\n----\n\n* Support Calamari's \"extended prediction data\" output\n* Currently, the processor only supports a prediction using confidence voting of multiple models. While this is\n  superior, it makes sense to support single model prediction, too.\n", "setup.py": "# -*- coding: utf-8 -*-\nimport codecs\n\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='ocrd_calamari',\n    version='0.0.1',\n    description='Calamari bindings',\n    long_description=codecs.open('README.md', encoding='utf-8').read(),\n    author='Konstantin Baierer, Mike Gerber',\n    author_email='unixprog@gmail.com, mike.gerber@sbb.spk-berlin.de',\n    url='https://github.com/kba/ocrd_calamari',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    install_requires=open('requirements.txt').read().split('\\n'),\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    entry_points={\n        'console_scripts': [\n            'ocrd-calamari-recognize=ocrd_calamari.cli:ocrd_calamari_recognize',\n        ]\n    },\n)\n"}, "ocrd_tool": {"git_url": "https://github.com/kba/ocrd_calamari", "version": "0.0.1", "tools": {"ocrd-calamari-recognize": {"executable": "ocrd-calamari-recognize", "categories": ["Text recognition and optimization"], "steps": ["recognition/text-recognition"], "description": "Recognize lines with Calamari", "input_file_grp": ["OCR-D-SEG-LINE"], "output_file_grp": ["OCR-D-OCR-CALAMARI"], "parameters": {"checkpoint": {"type": "string", "format": "file", "cacheable": true}, "voter": {"type": "string", "default": "confidence_voter_default_ctc"}}}}}, "git": {"number_of_commits": "29", "last_commit": "Thu Aug 22 14:03:59 2019 +0200"}, "python": {"url": "https://github.com/kba/ocrd_calamari", "name": "ocrd_calamari", "author": "Konstantin Baierer, Mike Gerber", "author-email": "unixprog@gmail.com, mike.gerber@sbb.spk-berlin.de"}}, {"url": "https://github.com/OCR-D/ocrd_im6convert", "org_plus_name": "OCR-D/ocrd_im6convert", "name": "ocrd_im6convert", "files": {"ocrd-tool.json": "{\n  \"git_url\": \"https://github.com/OCR-D/ocrd_im6convert\",\n  \"version\": \"0.0.1\",\n  \"tools\": {\n\n    \"ocrd-im6convert\": {\n      \"executable\": \"ocrd-im6convert\",\n      \"categories\": [\"Image preprocessing\"],\n      \"steps\": [\"preprocessing/optimization/binarization\"],\n      \"description\": \"Convert and transform images \",\n      \"parameters\": {\n        \"output-format\": {\n          \"type\": \"string\",\n          \"required\": true,\n          \"enum\": [\"image/tiff\", \"image/jp2\", \"image/png\"]\n        }\n      }\n    }\n\n  }\n}\n", "Dockerfile": null, "README.md": "# ocrd_imageconvert/\n\n> Thin wrapper around convert(1)\n\nRequires: ocrd >= 0.4.2\n\n## What it does\n\n```sh\n\n# Actual conversion\nconvert \"$infile\" \"$outfile\"\n```\n\n## What it could do\n\n[One or more of these](http://www.fmwconcepts.com/imagemagick/textcleaner/index.php) or\n[these](http://web.archive.org/web/20110517204536/http://www.ict.griffith.edu.au/anthony/graphics/imagick6/quantize/)\nor convert to grayscale, binarize etc. With threshold configurable as a\nparameter.\n", "setup.py": null}, "ocrd_tool": {"git_url": "https://github.com/OCR-D/ocrd_im6convert", "version": "0.0.1", "tools": {"ocrd-im6convert": {"executable": "ocrd-im6convert", "categories": ["Image preprocessing"], "steps": ["preprocessing/optimization/binarization"], "description": "Convert and transform images ", "parameters": {"output-format": {"type": "string", "required": true, "enum": ["image/tiff", "image/jp2", "image/png"]}}}}}, "git": {"number_of_commits": "6", "last_commit": "Wed Jul 18 18:17:27 2018 +0200"}, "python": {"url": "", "name": "", "author": "", "author-email": ""}}, {"url": "https://github.com/OCR-D/ocrd_keraslm", "org_plus_name": "OCR-D/ocrd_keraslm", "name": "ocrd_keraslm", "files": {"ocrd-tool.json": null, "Dockerfile": null, "README.md": "# ocrd_keraslm\n    character-level language modelling using Keras\n\n\n## Introduction\n\nThis is a tool for statistical _language modelling_ (predicting text from context) with recurrent neural networks. It models probabilities not on the word level but the _character level_ so as to allow open vocabulary processing (avoiding morphology, historic orthography and word segmentation problems). It manages a vocabulary of mapped characters, which can be easily extended by training on more text. Above that, unmapped characters are treated with underspecification.\n\nIn addition to character sequences, (meta-data) context variables can be configured as extra input. \n\n### Architecture\n\nThe model consists of:\n\n0. an input layer: characters are represented as indexes from the vocabulary mapping, in windows of a number `length` of characters,\n1. a character embedding layer: window sequences are converted into dense vectors by looking up the indexes in an embedding weight matrix,\n2. a context embedding layer: context variables are converted into dense vectors by looking up the indexes in an embedding weight matrix, \n3. character and context vector sequences are concatenated,\n4. a number `depth` of hidden layers: each with a number `width` of hidden recurrent units of _LSTM cells_ (Long Short-term Memory) connected on top of each other,\n5. an output layer derived from the transposed character embedding matrix (weight tying): hidden activations are projected linearly to vectors of dimensionality equal to the character vocabulary size, then softmax is applied returning a probability for each possible value of the next character, respectively.\n\n![model graph depiction](model-graph.png \"graph with 1 context variable\")\n\nThe model is trained by feeding windows of text in index representation to the input layer, calculating output and comparing it to the same text shifted backward by 1 character, and represented as unit vectors (\"one-hot coding\") as target. The loss is calculated as the (unweighted) cross-entropy between target and output. Backpropagation yields error gradients for each layer, which is used to iteratively update the weights (stochastic gradient descent).\n\nThis is implemented in [Keras](https://keras.io) with [Tensorflow](https://www.tensorflow.org/) as backend. It automatically uses a fast CUDA-optimized LSTM implementation (Nividia GPU and Tensorflow installation with GPU support, see below), both in learning and in prediction phase, if available.\n\n\n### Modes of operation\n\nNotably, this model (by default) runs _statefully_, i.e. by implicitly passing hidden state from one window (batch of samples) to the next. That way, the context available for predictions can be arbitrarily long (above `length`, e.g. the complete document up to that point), or short (below `length`, e.g. at the start of a text). (However, this is a passive perspective above `length`, because errors are never back-propagated any further in time during gradient-descent training.) This is favourable to stateless mode because all characters can be output in parallel, and no partial windows need to be presented during training (which slows down).\n\nBesides stateful mode, the model can also be run _incrementally_, i.e. by explicitly passing hidden state from the caller. That way, multiple alternative hypotheses can be processed together. This is used for generation (sampling from the model) and alternative decoding (finding the best path through a sequence of alternatives).\n\n### Context conditioning\n\nEvery text has meta-data like time, author, text type, genre, production features (e.g. print vs typewriter vs digital born rich text, OCR version), language, structural element (e.g. title vs heading vs paragraph vs footer vs marginalia), font family (e.g. Antiqua vs Fraktura) and font shape (e.g. bold vs letter-spaced vs italic vs normal) etc. \n\nThis information (however noisy) can be very useful to facilitate stochastic modelling, since language has an extreme diversity and complexity. To that end, models can be conditioned on extra inputs here, termed _context variables_. The model learns to represent these high-dimensional discrete values as low-dimensional continuous vectors (embeddings), also entering the recurrent hidden layers (as a form of simple additive adaptation).\n\n### Underspecification\n\nIndex zero is reserved for unmapped characters (unseen contexts). During training, its embedding vector is regularised to occupy a center position of all mapped characters (all other contexts), and the hidden layers get to see it every now and then by random degradation. At runtime, therefore, some unknown character (some unknown context) represented as zero does not disturb follow-up predictions too much.\n\n\n## Installation\n\nRequired Ubuntu packages:\n\n* Python (``python`` or ``python3``)\n* pip (``python-pip`` or ``python3-pip``)\n* virtualenv (``python-virtualenv`` or ``python3-virtualenv``)\n\nCreate and activate a virtualenv as usual.\n\nIf you need a custom version of ``keras`` or ``tensorflow`` (like [GPU support](https://www.tensorflow.org/install/install_sources)), install them via `pip` now.\n\nTo install Python dependencies and this module, then do:\n```shell\nmake deps install\n```\nWhich is the equivalent of:\n```shell\npip install -r requirements.txt\npip install -e .\n```\n\nUseful environment variables are:\n- ``TF_CPP_MIN_LOG_LEVEL`` (set to `1` to suppress most of Tensorflow's messages\n- ``CUDA_VISIBLE_DEVICES`` (set empty to force CPU even in a GPU installation)\n\n\n## Usage\n\nThis packages has two user interfaces:\n\n### command line interface `keraslm-rate`\n\nTo be used with string arguments and plain-text files.\n\n```shell\nUsage: keraslm-rate [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  train                           train a language model\n  test                            get overall perplexity from language model\n  apply                           get individual probabilities from language model\n  generate                        sample characters from language model\n  print-charset                   Print the mapped characters\n  prune-charset                   Delete one character from mapping\n  plot-char-embeddings-similarity\n                                  Paint a heat map of character embeddings\n  plot-context-embeddings-similarity\n                                  Paint a heat map of context embeddings\n  plot-context-embeddings-projection\n                                  Paint a 2-d PCA projection of context embeddings\n```\n\nExamples:\n```shell\nkeraslm-rate train --width 64 --depth 4 --length 256 --model model_dta_64_4_256.h5 dta_komplett_2017-09-01/txt/*.tcf.txt\nkeraslm-rate generate -m model_dta_64_4_256.h5 --number 6 \"f\u00fcr die Wi\u017f\u017fen\"\nkeraslm-rate apply -m model_dta_64_4_256.h5 \"so sch\u00e4dlich ist es Borkickheile zu pflanzen\"\nkeraslm-rate test -m model_dta_64_4_256.h5 dta_komplett_2017-09-01/txt/grimm_*.tcf.txt\n```\n\n### [OCR-D processor](https://github.com/OCR-D/core) interface `ocrd-keraslm-rate`\n\nTo be used with [PageXML](https://www.primaresearch.org/tools/PAGELibraries) documents in an [OCR-D](https://github.com/OCR-D/spec/) annotation workflow. Input could be anything with a textual annotation (`TextEquiv` on the given `textequiv_level`). The LM rater could be used for both quality control (without alternative decoding, using only each first index `TextEquiv`) and part of post-correction (with `alternative_decoding=True`, finding the best path among `TextEquiv` indexes).\n\n```json\n  \"tools\": {\n    \"ocrd-keraslm-rate\": {\n      \"executable\": \"ocrd-keraslm-rate\",\n      \"categories\": [\n        \"Text recognition and optimization\"\n      ],\n      \"steps\": [\n        \"recognition/text-recognition\"\n      ],\n      \"description\": \"Rate elements of the text with a character-level LSTM language model in Keras\",\n      \"input_file_grp\": [\n        \"OCR-D-OCR-TESS\",\n        \"OCR-D-OCR-KRAK\",\n        \"OCR-D-OCR-OCRO\",\n        \"OCR-D-OCR-CALA\",\n        \"OCR-D-OCR-ANY\",\n        \"OCR-D-COR-CIS\",\n        \"OCR-D-COR-ASV\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-COR-LM\"\n      ],\n      \"parameters\": {\n        \"model_file\": {\n          \"type\": \"string\",\n          \"format\": \"uri\",\n          \"content-type\": \"application/x-hdf;subtype=bag\",\n          \"description\": \"path of h5py weight/config file for model trained with keraslm\",\n          \"required\": true,\n          \"cacheable\": true\n        },\n        \"textequiv_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"region\", \"line\", \"word\", \"glyph\"],\n          \"default\": \"glyph\",\n          \"description\": \"PAGE XML hierarchy level to evaluate TextEquiv sequences on\"\n        },\n        \"alternative_decoding\": {\n          \"type\": \"boolean\",\n          \"description\": \"whether to process all TextEquiv alternatives, finding the best path via beam search, and delete each non-best alternative\",\n          \"default\": true\n        },\n        \"beam_width\": {\n          \"type\": \"number\",\n          \"format\": \"integer\",\n          \"description\": \"maximum number of best partial paths to consider during search with alternative_decoding\",\n          \"default\": 100\n        }\n      }\n    }\n  }\n```\n\nExamples:\n```shell\nmake deps-test # installs ocrd_tesserocr\nmake test/assets # downloads GT, imports PageXML, builds workspaces\nocrd workspace clone -a test/assets/kant_aufklaerung_1784/mets.xml ws1\ncd ws1\nocrd-tesserocr-segment-region -I OCR-D-IMG -O OCR-D-SEG-BLOCK\nocrd-tesserocr-segment-line -I OCR-D-SEG-BLOCK -O OCR-D-SEG-LINE\nocrd-tesserocr-recognize -I OCR-D-SEG-LINE -O OCR-D-OCR-TESS-WORD -p '{ \"textequiv_level\" : \"word\", \"model\" : \"Fraktur\" }'\nocrd-tesserocr-recognize -I OCR-D-SEG-LINE -O OCR-D-OCR-TESS-GLYPH -p '{ \"textequiv_level\" : \"glyph\", \"model\" : \"deu-frak\" }'\n# get confidences and perplexity:\nocrd-keraslm-rate -I OCR-D-OCR-TESS-WORD -O OCR-D-OCR-LM-WORD -p '{ \"model_file\": \"model_dta_64_4_256.h5\", \"textequiv_level\": \"word\", \"alternative_decoding\": false }'\n# also get best path:\nocrd-keraslm-rate -I OCR-D-OCR-TESS-GLYPH -O OCR-D-OCR-LM-GLYPH -p '{ \"model_file\": \"model_dta_64_4_256.h5\", \"textequiv_level\": \"glyph\", \"alternative_decoding\": true, \"beam_width\": 10 }'\n```\n\n## Testing\n\n```shell\nmake deps-test test\n```\nWhich is the equivalent of:\n```shell\npip install -r requirements_test.txt\ntest -e test/assets || test/prepare_gt.bash test/assets\ntest -f model_dta_test.h5 || keraslm-rate train -m model_dta_test.h5 test/assets/*.txt\nkeraslm-rate test -m model_dta_test.h5 test/assets/*.txt\npython -m pytest test $(PYTEST_ARGS)\n```\n\nSet `PYTEST_ARGS=\"-s --verbose\"` to see log output (`-s`) and individual test results (`--verbose`).\n", "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nInstalls:\n    - keraslm-rate\n\"\"\"\nimport codecs\n\nfrom setuptools import setup, find_packages\n\nwith codecs.open('README.md', encoding='utf-8') as f:\n    README = f.read()\n\nsetup(\n    name='ocrd_keraslm',\n    version='0.3.1',\n    description='character-level language modelling in Keras',\n    long_description=README,\n    author='Konstantin Baierer, Kay-Michael W\u00fcrzner',\n    author_email='unixprog@gmail.com, wuerzner@gmail.com',\n    url='https://github.com/OCR-D/ocrd_keraslm',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    install_requires=[\n        'ocrd >= 0.15.2',\n        'keras',\n        'click',\n        'numpy',\n        'tensorflow',\n        'h5py',\n        'networkx',\n    ],\n    extras_require={\n        'plotting': [\n            'sklearn',\n            'matplotlib',\n            ]\n    },\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    entry_points={\n        'console_scripts': [\n            'keraslm-rate=ocrd_keraslm.scripts.run:cli',\n            'ocrd-keraslm-rate=ocrd_keraslm.wrapper.cli:ocrd_keraslm_rate',\n        ]\n    },\n)\n"}, "ocrd_tool": null, "git": {"number_of_commits": "75", "last_commit": "Fri Jul 19 13:01:17 2019 +0200"}, "python": {"url": "https://github.com/OCR-D/ocrd_keraslm", "name": "ocrd_keraslm", "author": "Konstantin Baierer, Kay-Michael W\u00fcrzner", "author-email": "unixprog@gmail.com, wuerzner@gmail.com"}}, {"url": "https://github.com/OCR-D/ocrd_kraken", "org_plus_name": "OCR-D/ocrd_kraken", "name": "ocrd_kraken", "files": {"ocrd-tool.json": "{\n  \"git_url\": \"https://github.com/OCR-D/ocrd_kraken\",\n  \"version\": \"0.0.2\",\n  \"tools\": {\n    \"ocrd-kraken-binarize\": {\n      \"executable\": \"ocrd-kraken-binarize\",\n      \"input_file_grp\": \"OCR-D-IMG\",\n      \"output_file_grp\": \"OCR-D-IMG-BIN\",\n      \"categories\": [\n        \"Image preprocessing\"\n      ],\n      \"steps\": [\n        \"preprocessing/optimization/binarization\"\n      ],\n      \"description\": \"Binarize images with kraken\",\n      \"parameters\": {\n        \"level-of-operation\": {\n          \"type\": \"string\",\n          \"default\": \"page\",\n          \"enum\": [\"page\", \"block\", \"line\"]\n        }\n      }\n    },\n    \"ocrd-kraken-segment\": {\n      \"executable\": \"ocrd-kraken-segment\",\n      \"categories\": [\n        \"Layout analysis\"\n      ],\n      \"steps\": [\n        \"layout/segmentation/region\"\n      ],\n      \"description\": \"Block segmentation with kraken\",\n      \"parameters\": {\n        \"text_direction\": {\n          \"type\": \"string\",\n          \"description\": \"Sets principal text direction\",\n          \"enum\": [\"horizontal-lr\", \"horizontal-rl\", \"vertical-lr\", \"vertical-rl\"],\n          \"default\": \"horizontal-lr\"\n        },\n        \"script_detect\": {\n          \"type\": \"boolean\",\n          \"description\": \"Enable script detection on segmenter output\",\n          \"default\": false\n        },\n        \"maxcolseps\": {\"type\": \"number\", \"format\": \"integer\", \"default\": 2},\n        \"scale\": {\"type\": \"number\", \"format\": \"float\", \"default\": null},\n        \"black_colseps\": {\"type\": \"boolean\", \"default\": false},\n        \"white_colseps\": {\"type\": \"boolean\", \"default\": false}\n      }\n    },\n    \"ocrd-kraken-ocr\": {\n      \"executable\": \"ocrd-kraken-ocr\",\n      \"categories\": [\"Text recognition and optimization\"],\n      \"steps\": [\n        \"recognition/text-recognition\"\n      ],\n      \"description\": \"OCR with kraken\",\n      \"parameters\": {\n        \"lines-json\": {\n          \"type\": \"string\",\n          \"format\": \"url\",\n          \"required\": \"true\",\n          \"description\": \"URL to line segmentation in JSON\"\n        }\n      }\n    }\n\n  }\n}\n", "Dockerfile": "FROM ocrd/core\nMAINTAINER OCR-D\nENV DEBIAN_FRONTEND noninteractive\nENV PYTHONIOENCODING utf8\nENV LC_ALL C.UTF-8\nENV LANG C.UTF-8\n\nWORKDIR /build-ocrd\nCOPY setup.py .\nCOPY requirements.txt .\nCOPY README.rst .\nRUN apt-get update && \\\n    apt-get -y install --no-install-recommends \\\n    ca-certificates \\\n    make \\\n    git\nCOPY ocrd_kraken ./ocrd_kraken\nRUN pip3 install --upgrade pip\nRUN make deps-pip install\n\nENTRYPOINT [\"/bin/sh\", \"-c\"]\n", "README.md": "# ocrd_kraken\n\n> Wrapper for the kraken OCR engine\n\n[![image](https://travis-ci.org/OCR-D/ocrd_kraken.svg?branch=master)](https://travis-ci.org/OCR-D/ocrd_kraken)\n[![Docker Automated build](https://img.shields.io/docker/automated/ocrd/kraken.svg)](https://hub.docker.com/r/ocrd/kraken/tags/)\n[![image](https://circleci.com/gh/OCR-D/ocrd_kraken.svg?style=svg)](https://circleci.com/gh/OCR-D/ocrd_kraken)\n", "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nInstalls two binaries:\n\n    - ocrd-kraken-binarize\n    - ocrd-kraken-segment\n\"\"\"\nimport codecs\n\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='ocrd_kraken',\n    version='0.1.0',\n    description='kraken bindings',\n    long_description=codecs.open('README.md', encoding='utf-8').read(),\n    long_description_content_type='text/markdown',\n    author='Konstantin Baierer, Kay-Michael W\u00fcrzner',\n    author_email='unixprog@gmail.com, wuerzner@gmail.com',\n    url='https://github.com/OCR-D/ocrd_kraken',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    install_requires=[\n        'ocrd >= 1.0.0a4',\n        'kraken == 0.9.16',\n        'click >= 7',\n    ],\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    entry_points={\n        'console_scripts': [\n            'ocrd-kraken-binarize=ocrd_kraken.cli:ocrd_kraken_binarize',\n            'ocrd-kraken-segment=ocrd_kraken.cli:ocrd_kraken_segment',\n        ]\n    },\n)\n"}, "ocrd_tool": {"git_url": "https://github.com/OCR-D/ocrd_kraken", "version": "0.0.2", "tools": {"ocrd-kraken-binarize": {"executable": "ocrd-kraken-binarize", "input_file_grp": "OCR-D-IMG", "output_file_grp": "OCR-D-IMG-BIN", "categories": ["Image preprocessing"], "steps": ["preprocessing/optimization/binarization"], "description": "Binarize images with kraken", "parameters": {"level-of-operation": {"type": "string", "default": "page", "enum": ["page", "block", "line"]}}}, "ocrd-kraken-segment": {"executable": "ocrd-kraken-segment", "categories": ["Layout analysis"], "steps": ["layout/segmentation/region"], "description": "Block segmentation with kraken", "parameters": {"text_direction": {"type": "string", "description": "Sets principal text direction", "enum": ["horizontal-lr", "horizontal-rl", "vertical-lr", "vertical-rl"], "default": "horizontal-lr"}, "script_detect": {"type": "boolean", "description": "Enable script detection on segmenter output", "default": false}, "maxcolseps": {"type": "number", "format": "integer", "default": 2}, "scale": {"type": "number", "format": "float", "default": null}, "black_colseps": {"type": "boolean", "default": false}, "white_colseps": {"type": "boolean", "default": false}}}, "ocrd-kraken-ocr": {"executable": "ocrd-kraken-ocr", "categories": ["Text recognition and optimization"], "steps": ["recognition/text-recognition"], "description": "OCR with kraken", "parameters": {"lines-json": {"type": "string", "format": "url", "required": "true", "description": "URL to line segmentation in JSON"}}}}}, "git": {"number_of_commits": "80", "last_commit": "Thu Feb 28 10:37:14 2019 +0100"}, "python": {"url": "https://github.com/OCR-D/ocrd_kraken", "name": "ocrd_kraken", "author": "Konstantin Baierer, Kay-Michael W\u00fcrzner", "author-email": "unixprog@gmail.com, wuerzner@gmail.com"}}, {"url": "https://github.com/OCR-D/ocrd_ocropy", "org_plus_name": "OCR-D/ocrd_ocropy", "name": "ocrd_ocropy", "files": {"ocrd-tool.json": "{\n  \"version\": \"0.0.1\",\n  \"git_url\": \"https://github.com/OCR-D/ocrd_ocropy\",\n  \"tools\": {\n    \"ocrd-ocropy-segment\": {\n      \"executable\": \"ocrd-ocropy-segment\",\n      \"categories\": [\"Image preprocessing\"],\n      \"steps\": [\"layout/segmentation/region\"],\n      \"description\": \"Segment page\",\n      \"input_file_grp\": [\"OCR-D-IMG-BIN\"],\n      \"output_file_grp\": [\"OCR-D-SEG-LINE\"],\n      \"parameters\": {\n        \"maxcolseps\":  {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 3},\n        \"maxseps\":     {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 0},\n        \"sepwiden\":    {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 10},\n        \"csminheight\": {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 10},\n        \"csminaspect\": {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 1.1},\n        \"pad\":         {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 3},\n        \"expand\":      {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 3},\n        \"usegauss\":    {\"type\": \"boolean\",\"description\": \"has an effect\", \"default\": false},\n        \"threshold\":   {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 0.2},\n        \"noise\":       {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 8},\n        \"scale\":       {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 0.0},\n        \"hscale\":      {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 1.0},\n        \"vscale\":      {\"type\": \"number\", \"description\": \"has an effect\", \"default\": 1.0}\n      }\n    }\n  }\n}\n", "Dockerfile": "FROM ocrd/core\nMAINTAINER OCR-D\nENV DEBIAN_FRONTEND noninteractive\nENV PYTHONIOENCODING utf8\nENV LC_ALL C.UTF-8\nENV LANG C.UTF-8\n\nWORKDIR /build-ocrd\nCOPY setup.py .\nCOPY requirements.txt .\nCOPY README.rst .\nRUN apt-get update && \\\n    apt-get -y install --no-install-recommends \\\n    ca-certificates \\\n    make \\\n    git\nCOPY ocrd_ocropy ./ocrd_ocropy\nRUN pip3 install --upgrade pip\nRUN make deps-pip install\n\nENTRYPOINT [\"/bin/sh\", \"-c\"]\n", "README.md": "# ocrd_ocropy\n\n[![image](https://travis-ci.org/OCR-D/ocrd_ocropy.svg?branch=master)](https://travis-ci.org/OCR-D/ocrd_ocropy)\n\n[![Docker Automated build](https://img.shields.io/docker/automated/ocrd/ocropy.svg)](https://hub.docker.com/r/ocrd/ocropy/tags/)\n\n> Wrapper for the ocropy OCR engine\n", "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nInstalls one binary:\n\n    - ocrd-ocropy-segment\n\"\"\"\nimport codecs\n\nfrom setuptools import setup\n\nsetup(\n    name='ocrd_ocropy',\n    version='0.0.1a1',\n    description='ocropy bindings',\n    long_description=codecs.open('README.md', encoding='utf-8').read(),\n    long_description_content_type='text/markdown',\n    author='Konstantin Baierer',\n    author_email='unixprog@gmail.com, wuerzner@gmail.com',\n    url='https://github.com/OCR-D/ocrd_ocropy',\n    license='Apache License 2.0',\n    packages=['ocrd_ocropy'],\n    install_requires=[\n        'ocrd >= 1.0.0b6',\n        'ocrd-fork-ocropy >= 1.4.0a3',\n        'click'\n    ],\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    entry_points={\n        'console_scripts': [\n            'ocrd-ocropy-segment=ocrd_ocropy.cli:ocrd_ocropy_segment',\n        ]\n    },\n)\n"}, "ocrd_tool": {"version": "0.0.1", "git_url": "https://github.com/OCR-D/ocrd_ocropy", "tools": {"ocrd-ocropy-segment": {"executable": "ocrd-ocropy-segment", "categories": ["Image preprocessing"], "steps": ["layout/segmentation/region"], "description": "Segment page", "input_file_grp": ["OCR-D-IMG-BIN"], "output_file_grp": ["OCR-D-SEG-LINE"], "parameters": {"maxcolseps": {"type": "number", "description": "has an effect", "default": 3}, "maxseps": {"type": "number", "description": "has an effect", "default": 0}, "sepwiden": {"type": "number", "description": "has an effect", "default": 10}, "csminheight": {"type": "number", "description": "has an effect", "default": 10}, "csminaspect": {"type": "number", "description": "has an effect", "default": 1.1}, "pad": {"type": "number", "description": "has an effect", "default": 3}, "expand": {"type": "number", "description": "has an effect", "default": 3}, "usegauss": {"type": "boolean", "description": "has an effect", "default": false}, "threshold": {"type": "number", "description": "has an effect", "default": 0.2}, "noise": {"type": "number", "description": "has an effect", "default": 8}, "scale": {"type": "number", "description": "has an effect", "default": 0.0}, "hscale": {"type": "number", "description": "has an effect", "default": 1.0}, "vscale": {"type": "number", "description": "has an effect", "default": 1.0}}}}}, "git": {"number_of_commits": "60", "last_commit": "Thu Feb 28 16:30:26 2019 +0100"}, "python": {"url": "https://github.com/OCR-D/ocrd_ocropy", "name": "ocrd_ocropy", "author": "Konstantin Baierer", "author-email": "unixprog@gmail.com, wuerzner@gmail.com"}}, {"url": "https://github.com/OCR-D/ocrd_olena", "org_plus_name": "OCR-D/ocrd_olena", "name": "ocrd_olena", "files": {"ocrd-tool.json": "{\n  \"version\": \"0.0.2\",\n  \"git_url\": \"https://github.com/OCR-D/ocrd_olena\",\n  \"tools\": {\n    \"ocrd-olena-binarize\": {\n      \"executable\": \"ocrd-olena-binarize\",\n      \"description\": \"OLENA's binarization algos for OCR-D (on page-level)\",\n      \"categories\": [\n        \"Image preprocessing\"\n      ],\n      \"steps\": [\n        \"preprocessing/optimization/binarization\"\n      ],\n      \"input_file_grp\": [\n        \"OCR-D-SEG-BLOCK\",\n        \"OCR-D-SEG-LINE\",\n        \"OCR-D-SEG-WORD\",\n        \"OCR-D-IMG\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-SEG-BLOCK\",\n        \"OCR-D-SEG-LINE\",\n        \"OCR-D-SEG-WORD\"\n      ],\n      \"parameters\": {\n        \"impl\": {\n          \"description\": \"The name of the actual binarization algorithm\",\n          \"type\": \"string\",\n          \"required\": true,\n          \"enum\": [\"sauvola\", \"sauvola-ms\", \"sauvola-ms-fg\", \"sauvola-ms-split\", \"kim\", \"wolf\", \"niblack\", \"singh\", \"otsu\"]\n        },\n        \"win-size\": {\n          \"description\": \"Window size\",\n          \"type\": \"number\",\n          \"format\": \"integer\",\n          \"default\": 101\n        },\n        \"k\": {\n          \"description\": \"Sauvola's formulae parameter\",\n          \"format\": \"float\",\n          \"type\": \"number\",\n          \"default\": 0.34\n        }\n      }\n    }\n  }\n}\n", "Dockerfile": null, "README.md": "# ocrd_olena\n\n> Bundle olena as an OCR-D tool\n\n[![Build Status](https://travis-ci.org/OCR-D/ocrd_olena.svg?branch=master)](https://travis-ci.org/OCR-D/ocrd_olena)\n\n## Requirements\n\n```\nmake deps-ubuntu\n```\n\n...will try to install the required packages on Ubuntu.\n\n## Installation\n\n```\nmake install\n```\n\n...will download, patch and build olena/scribo from source, and install locally (in a path relative to the CWD).\n\n## Testing\n\n```\nmake test\n```\n\n...will clone the assets repository from Github, make a workspace copy, and run checksum tests for binarization on them.\n\n## Usage\n\nThis package has the following user interfaces:\n\n### [OCR-D processor](https://github.com/OCR-D/core) interface `ocrd-olena-binarize`\n\nTo be used with [PageXML](https://www.primaresearch.org/tools/PAGELibraries) documents in an [OCR-D](https://github.com/OCR-D/spec/) annotation workflow. Input could be any valid workspace with source images available. Currently covers the `Page` hierarchy level only. Uses either (the last) `AlternativeImage`, if any, or `imageFilename`, otherwise. Adds an `AlternativeImage` with the result of binarization for every page.\n\n```json\n    \"ocrd-olena-binarize\": {\n      \"executable\": \"ocrd-olena-binarize\",\n      \"description\": \"OLENA's binarization algos for OCR-D (on page-level)\",\n      \"categories\": [\n        \"Image preprocessing\"\n      ],\n      \"steps\": [\n        \"preprocessing/optimization/binarization\"\n      ],\n      \"input_file_grp\": [\n        \"OCR-D-SEG-BLOCK\",\n        \"OCR-D-SEG-LINE\",\n        \"OCR-D-SEG-WORD\",\n        \"OCR-D-IMG\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-SEG-BLOCK\",\n        \"OCR-D-SEG-LINE\",\n        \"OCR-D-SEG-WORD\"\n      ],\n      \"parameters\": {\n        \"impl\": {\n          \"description\": \"The name of the actual binarization algorithm\",\n          \"type\": \"string\",\n          \"required\": true,\n          \"enum\": [\"sauvola\", \"sauvola-ms\", \"sauvola-ms-fg\", \"sauvola-ms-split\", \"kim\", \"wolf\", \"niblack\", \"singh\", \"otsu\"]\n        },\n        \"win-size\": {\n          \"description\": \"Window size\",\n          \"type\": \"number\",\n          \"format\": \"integer\",\n          \"default\": 101\n        },\n        \"k\": {\n          \"description\": \"Sauvola's formulae parameter\",\n          \"format\": \"float\",\n          \"type\": \"number\",\n          \"default\": 0.34\n        }\n      }\n    }\n```\n", "setup.py": null}, "ocrd_tool": {"version": "0.0.2", "git_url": "https://github.com/OCR-D/ocrd_olena", "tools": {"ocrd-olena-binarize": {"executable": "ocrd-olena-binarize", "description": "OLENA's binarization algos for OCR-D (on page-level)", "categories": ["Image preprocessing"], "steps": ["preprocessing/optimization/binarization"], "input_file_grp": ["OCR-D-SEG-BLOCK", "OCR-D-SEG-LINE", "OCR-D-SEG-WORD", "OCR-D-IMG"], "output_file_grp": ["OCR-D-SEG-BLOCK", "OCR-D-SEG-LINE", "OCR-D-SEG-WORD"], "parameters": {"impl": {"description": "The name of the actual binarization algorithm", "type": "string", "required": true, "enum": ["sauvola", "sauvola-ms", "sauvola-ms-fg", "sauvola-ms-split", "kim", "wolf", "niblack", "singh", "otsu"]}, "win-size": {"description": "Window size", "type": "number", "format": "integer", "default": 101}, "k": {"description": "Sauvola's formulae parameter", "format": "float", "type": "number", "default": 0.34}}}}}, "git": {"number_of_commits": "47", "last_commit": "Mon Sep 9 22:21:57 2019 +0200"}, "python": {"url": "", "name": "", "author": "", "author-email": ""}}, {"url": "https://github.com/OCR-D/ocrd_segment", "org_plus_name": "OCR-D/ocrd_segment", "name": "ocrd_segment", "files": {"ocrd-tool.json": "{\n  \"version\": \"0.0.1\",\n  \"git_url\": \"https://github.com/OCR-D/ocrd_segment\",\n  \"tools\": {\n    \"ocrd-segment-repair\": {\n      \"executable\": \"ocrd-segment-repair\",\n      \"categories\": [\"Layout analysis\"],\n      \"description\": \"Analyse and repair region segmentation\",\n      \"input_file_grp\": [\n        \"OCR-D-IMG\",\n        \"OCR-D-SEG-BLOCK\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-EVAL-BLOCK\"\n      ],\n      \"steps\": [\"layout/segmentation/region\"],\n      \"parameters\": {\n        \"sanitize\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"Shrink and/or expand a region in such a way that it coordinates include those of all its lines\"\n        },\n        \"plausibilize\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"Modify the region segmentation to make it (more) plausible\"\n        }\n      }\n    },\n    \"ocrd-segment-evaluate\": {\n      \"executable\": \"ocrd-segment-evaluate\",\n      \"categories\": [\"Layout analysis\"],\n      \"description\": \"Compare region segmentations\",\n      \"input_file_grp\": [\n        \"OCR-D-GT-SEG-BLOCK\",\n        \"OCR-D-SEG-BLOCK\"\n      ],\n      \"steps\": [\"layout/analysis\"],\n      \"parameters\": {\n      }\n    }\n  }\n}\n", "Dockerfile": null, "README.md": "# ocrd_segment\n\nThis repository aims to provide a number of OCR-D-compliant processors for layout analysis and evaluation.\n\n  - pattern-based segmentation aka. `ocrd-segment-via-template` (input file groups N=1, based on a PAGE template, e.g. from Aletheia, and some XSLT or Python to apply it to the input file group)\n  - data-driven segmentation aka. `ocrd-segment-via-model` (input file groups N=1, based on a statistical model, e.g. Neural Network)\n  - comparing different layout segmentations aka. `ocrd-segment-evaluate` (input file groups N = 2, compute the distance between two segmentations, e.g. automatic vs. manual)\n  - repairing of layout segmentations aka. `ocrd-segment-repair` (input file groups N >= 1, based on heuristics implemented using Shapely)\n", "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nInstalls:\n\n    - ocrd-segment-repair\n    - ocrd-segment-evaluate\n\"\"\"\nimport codecs\n\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='ocrd_segment',\n    version='0.0.2',\n    description='Page segmentation and segmentation evaluation',\n    long_description=codecs.open('README.md', encoding='utf-8').read(),\n    author='Konstantin Baierer, Kay-Michael W\u00fcrzner, Robert Sachunsky',\n    author_email='unixprog@gmail.com, wuerzner@gmail.com, sachunsky@informatik.uni-leipzig.de',\n    url='https://github.com/OCR-D/ocrd_segment',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    install_requires=open('requirements.txt').read().split('\\n'),\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    entry_points={\n        'console_scripts': [\n            'ocrd-segment-repair=ocrd_segment.cli:ocrd_segment_repair',\n            'ocrd-segment-evaluate=ocrd_segment.cli:ocrd_segment_evaluate',\n        ]\n    },\n)\n"}, "ocrd_tool": {"version": "0.0.1", "git_url": "https://github.com/OCR-D/ocrd_segment", "tools": {"ocrd-segment-repair": {"executable": "ocrd-segment-repair", "categories": ["Layout analysis"], "description": "Analyse and repair region segmentation", "input_file_grp": ["OCR-D-IMG", "OCR-D-SEG-BLOCK"], "output_file_grp": ["OCR-D-EVAL-BLOCK"], "steps": ["layout/segmentation/region"], "parameters": {"sanitize": {"type": "boolean", "default": false, "description": "Shrink and/or expand a region in such a way that it coordinates include those of all its lines"}, "plausibilize": {"type": "boolean", "default": false, "description": "Modify the region segmentation to make it (more) plausible"}}}, "ocrd-segment-evaluate": {"executable": "ocrd-segment-evaluate", "categories": ["Layout analysis"], "description": "Compare region segmentations", "input_file_grp": ["OCR-D-GT-SEG-BLOCK", "OCR-D-SEG-BLOCK"], "steps": ["layout/analysis"], "parameters": {}}}}, "git": {"number_of_commits": "1", "last_commit": "Tue Sep 10 08:31:29 2019 +0200"}, "python": {"url": "https://github.com/OCR-D/ocrd_segment", "name": "ocrd_segment", "author": "Konstantin Baierer, Kay-Michael W\u00fcrzner, Robert Sachunsky", "author-email": "unixprog@gmail.com, wuerzner@gmail.com, sachunsky@informatik.uni-leipzig.de"}}, {"url": "https://github.com/OCR-D/ocrd_tesserocr", "org_plus_name": "OCR-D/ocrd_tesserocr", "name": "ocrd_tesserocr", "files": {"ocrd-tool.json": "{\n  \"version\": \"0.3.0\",\n  \"git_url\": \"https://github.com/OCR-D/ocrd_tesserocr\",\n  \"dockerhub\": \"ocrd/tesserocr\",\n  \"tools\": {\n    \"ocrd-tesserocr-deskew\": {\n      \"executable\": \"ocrd-tesserocr-deskew\",\n      \"categories\": [\"Image preprocessing\"],\n      \"description\": \"Deskew pages or regions\",\n      \"input_file_grp\": [\n        \"OCR-D-IMG\",\n        \"OCR-D-SEG-BLOCK\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-DESKEW-BLOCK\"\n      ],\n      \"steps\": [\"preprocessing/optimization/deskewing\"],\n      \"parameters\": {\n        \"operation_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"page\",\"region\"],\n          \"default\": \"region\",\n          \"description\": \"PAGE XML hierarchy level to operate on\"\n        }\n      }\n    },\n    \"ocrd-tesserocr-recognize\": {\n      \"executable\": \"ocrd-tesserocr-recognize\",\n      \"categories\": [\"Text recognition and optimization\"],\n      \"description\": \"Recognize text in lines with tesseract\",\n      \"input_file_grp\": [\n        \"OCR-D-SEG-BLOCK\",\n        \"OCR-D-SEG-LINE\",\n        \"OCR-D-SEG-WORD\",\n        \"OCR-D-SEG-GLYPH\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-OCR-TESS\"\n      ],\n      \"steps\": [\"recognition/text-recognition\"],\n      \"parameters\": {\n        \"textequiv_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"region\", \"line\", \"word\", \"glyph\"],\n          \"default\": \"line\",\n          \"description\": \"PAGE XML hierarchy level to add the TextEquiv results to (requires existing layout annotation up to one level above that)\"\n        },\n        \"overwrite_words\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"remove existing layout and text annotation below the TextLine level (regardless of textequiv_level)\"\n        },\n        \"model\": {\n          \"type\": \"string\",\n          \"description\": \"tessdata model to apply (an ISO 639-3 language specification or some other basename, e.g. deu-frak or Fraktur)\"\n        }\n      }\n    },\n     \"ocrd-tesserocr-segment-region\": {\n      \"executable\": \"ocrd-tesserocr-segment-region\",\n      \"categories\": [\"Layout analysis\"],\n      \"description\": \"Segment regions into lines with tesseract\",\n      \"input_file_grp\": [\n        \"OCR-D-IMG\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-SEG-BLOCK\"\n      ],\n      \"steps\": [\"layout/segmentation/region\"],\n      \"parameters\": {\n        \"overwrite_regions\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"remove existing layout and text annotation below the Page level\"\n        },\n        \"padding\": {\n          \"type\": \"number\",\n          \"format\": \"integer\",\n          \"description\": \"extend detected region rectangles by this many (true) pixels\",\n          \"default\": 8\n        },\n        \"crop_polygons\": {\n          \"type\": \"boolean\",\n          \"default\": false,\n          \"description\": \"annotate polygon coordinates instead of rectangles, and create cropped AlternativeImage masked by the polygon outlines\"\n        },\n        \"find_tables\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"recognise table regions (textord_tabfind_find_tables)\"\n        }\n      }\n    },\n    \"ocrd-tesserocr-segment-line\": {\n      \"executable\": \"ocrd-tesserocr-segment-line\",\n      \"categories\": [\"Layout analysis\"],\n      \"description\": \"Segment page into regions with tesseract\",\n      \"input_file_grp\": [\n        \"OCR-D-SEG-BLOCK\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-SEG-LINE\"\n      ],\n      \"steps\": [\"layout/segmentation/line\"],\n      \"parameters\": {\n        \"overwrite_lines\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"remove existing layout and text annotation below the TextRegion level\"\n        }\n      }\n    },\n    \"ocrd-tesserocr-segment-word\": {\n      \"executable\": \"ocrd-tesserocr-segment-word\",\n      \"categories\": [\"Layout analysis\"],\n      \"description\": \"Segment lines into words with tesseract\",\n      \"input_file_grp\": [\n        \"OCR-D-SEG-LINE\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-SEG-WORD\"\n      ],\n      \"steps\": [\"layout/segmentation/word\"],\n      \"parameters\": {\n        \"overwrite_words\": {\n          \"type\": \"boolean\",\n          \"default\": true,\n          \"description\": \"remove existing layout and text annotation below the TextLine level\"\n        }\n      }\n    },\n    \"ocrd-tesserocr-crop\": {\n      \"executable\": \"ocrd-tesserocr-crop\",\n      \"categories\": [\"Image preprocessing\"],\n      \"description\": \"Poor man's cropping with tesseract\",\n      \"input_file_grp\": [\n\t\"OCR-D-IMG\"\n      ],\n      \"output_file_grp\": [\n\t\"OCR-D-IMG-CROPPED\"\n      ],\n      \"steps\": [\"preprocessing/optimization/cropping\"],\n      \"parameters\" : {\n        \"padding\": {\n          \"type\": \"number\",\n          \"format\": \"integer\",\n          \"description\": \"extend detected border by this many (true) pixels on every side\",\n          \"default\": 4\n        }\n      }\n    },\n    \"ocrd-tesserocr-binarize\": {\n      \"executable\": \"ocrd-tesserocr-binarize\",\n      \"categories\": [\"Image preprocessing\"],\n      \"description\": \"Binarize regions or lines\",\n      \"input_file_grp\": [\n        \"OCR-D-IMG\",\n        \"OCR-D-SEG-BLOCK\",\n        \"OCR-D-SEG-LINE\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-BIN-BLOCK\",\n        \"OCR-D-BIN-LINE\"\n      ],\n      \"steps\": [\"preprocessing/optimization/binarization\"],\n      \"parameters\": {\n        \"operation_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"region\", \"line\"],\n          \"default\": \"region\",\n          \"description\": \"PAGE XML hierarchy level to operate on\"\n        }\n      }\n    }\n  }\n}\n", "Dockerfile": "FROM ocrd/core\nMAINTAINER OCR-D\nENV DEBIAN_FRONTEND noninteractive\nENV PYTHONIOENCODING utf8\nENV LC_ALL C.UTF-8\nENV LANG C.UTF-8\n\nWORKDIR /build-ocrd\nCOPY setup.py .\nCOPY requirements.txt .\nCOPY requirements_test.txt .\nCOPY README.rst .\nCOPY LICENSE .\nRUN apt-get update && \\\n    apt-get -y install --no-install-recommends \\\n    ca-certificates \\\n    make \\\n    git\nCOPY Makefile .\nRUN make deps-ubuntu\nCOPY ocrd_tesserocr ./ocrd_tesserocr\nRUN pip3 install --upgrade pip\nRUN make PYTHON=python3 PIP=pip3 deps install\nCOPY test ./test\nRUN make PYTHON=python3 PIP=pip3 deps-test\n\nENTRYPOINT [\"/bin/sh\", \"-c\"]\n", "README.md": null, "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nInstalls five executables:\n\n    - ocrd_tesserocr_recognize\n    - ocrd_tesserocr_segment_region\n    - ocrd_tesserocr_segment_line\n    - ocrd_tesserocr_segment_word\n    - ocrd_tesserocr_crop\n    - ocrd_tesserocr_deskew\n    - ocrd_tesserocr_binarize\n\"\"\"\nimport codecs\n\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='ocrd_tesserocr',\n    version='0.4.0',\n    description='Tesserocr bindings',\n    long_description=codecs.open('README.rst', encoding='utf-8').read(),\n    author='Konstantin Baierer, Kay-Michael W\u00fcrzner, Robert Sachunsky',\n    author_email='unixprog@gmail.com, wuerzner@gmail.com, sachunsky@informatik.uni-leipzig.de',\n    url='https://github.com/OCR-D/ocrd_tesserocr',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    install_requires=open('requirements.txt').read().split('\\n'),\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    entry_points={\n        'console_scripts': [\n            'ocrd-tesserocr-recognize=ocrd_tesserocr.cli:ocrd_tesserocr_recognize',\n            'ocrd-tesserocr-segment-region=ocrd_tesserocr.cli:ocrd_tesserocr_segment_region',\n            'ocrd-tesserocr-segment-line=ocrd_tesserocr.cli:ocrd_tesserocr_segment_line',\n            'ocrd-tesserocr-segment-word=ocrd_tesserocr.cli:ocrd_tesserocr_segment_word',\n            'ocrd-tesserocr-crop=ocrd_tesserocr.cli:ocrd_tesserocr_crop',\n            'ocrd-tesserocr-deskew=ocrd_tesserocr.cli:ocrd_tesserocr_deskew',\n            'ocrd-tesserocr-binarize=ocrd_tesserocr.cli:ocrd_tesserocr_binarize',\n        ]\n    },\n)\n"}, "ocrd_tool": {"version": "0.3.0", "git_url": "https://github.com/OCR-D/ocrd_tesserocr", "dockerhub": "ocrd/tesserocr", "tools": {"ocrd-tesserocr-deskew": {"executable": "ocrd-tesserocr-deskew", "categories": ["Image preprocessing"], "description": "Deskew pages or regions", "input_file_grp": ["OCR-D-IMG", "OCR-D-SEG-BLOCK"], "output_file_grp": ["OCR-D-DESKEW-BLOCK"], "steps": ["preprocessing/optimization/deskewing"], "parameters": {"operation_level": {"type": "string", "enum": ["page", "region"], "default": "region", "description": "PAGE XML hierarchy level to operate on"}}}, "ocrd-tesserocr-recognize": {"executable": "ocrd-tesserocr-recognize", "categories": ["Text recognition and optimization"], "description": "Recognize text in lines with tesseract", "input_file_grp": ["OCR-D-SEG-BLOCK", "OCR-D-SEG-LINE", "OCR-D-SEG-WORD", "OCR-D-SEG-GLYPH"], "output_file_grp": ["OCR-D-OCR-TESS"], "steps": ["recognition/text-recognition"], "parameters": {"textequiv_level": {"type": "string", "enum": ["region", "line", "word", "glyph"], "default": "line", "description": "PAGE XML hierarchy level to add the TextEquiv results to (requires existing layout annotation up to one level above that)"}, "overwrite_words": {"type": "boolean", "default": false, "description": "remove existing layout and text annotation below the TextLine level (regardless of textequiv_level)"}, "model": {"type": "string", "description": "tessdata model to apply (an ISO 639-3 language specification or some other basename, e.g. deu-frak or Fraktur)"}}}, "ocrd-tesserocr-segment-region": {"executable": "ocrd-tesserocr-segment-region", "categories": ["Layout analysis"], "description": "Segment regions into lines with tesseract", "input_file_grp": ["OCR-D-IMG"], "output_file_grp": ["OCR-D-SEG-BLOCK"], "steps": ["layout/segmentation/region"], "parameters": {"overwrite_regions": {"type": "boolean", "default": true, "description": "remove existing layout and text annotation below the Page level"}, "padding": {"type": "number", "format": "integer", "description": "extend detected region rectangles by this many (true) pixels", "default": 8}, "crop_polygons": {"type": "boolean", "default": false, "description": "annotate polygon coordinates instead of rectangles, and create cropped AlternativeImage masked by the polygon outlines"}, "find_tables": {"type": "boolean", "default": true, "description": "recognise table regions (textord_tabfind_find_tables)"}}}, "ocrd-tesserocr-segment-line": {"executable": "ocrd-tesserocr-segment-line", "categories": ["Layout analysis"], "description": "Segment page into regions with tesseract", "input_file_grp": ["OCR-D-SEG-BLOCK"], "output_file_grp": ["OCR-D-SEG-LINE"], "steps": ["layout/segmentation/line"], "parameters": {"overwrite_lines": {"type": "boolean", "default": true, "description": "remove existing layout and text annotation below the TextRegion level"}}}, "ocrd-tesserocr-segment-word": {"executable": "ocrd-tesserocr-segment-word", "categories": ["Layout analysis"], "description": "Segment lines into words with tesseract", "input_file_grp": ["OCR-D-SEG-LINE"], "output_file_grp": ["OCR-D-SEG-WORD"], "steps": ["layout/segmentation/word"], "parameters": {"overwrite_words": {"type": "boolean", "default": true, "description": "remove existing layout and text annotation below the TextLine level"}}}, "ocrd-tesserocr-crop": {"executable": "ocrd-tesserocr-crop", "categories": ["Image preprocessing"], "description": "Poor man's cropping with tesseract", "input_file_grp": ["OCR-D-IMG"], "output_file_grp": ["OCR-D-IMG-CROPPED"], "steps": ["preprocessing/optimization/cropping"], "parameters": {"padding": {"type": "number", "format": "integer", "description": "extend detected border by this many (true) pixels on every side", "default": 4}}}, "ocrd-tesserocr-binarize": {"executable": "ocrd-tesserocr-binarize", "categories": ["Image preprocessing"], "description": "Binarize regions or lines", "input_file_grp": ["OCR-D-IMG", "OCR-D-SEG-BLOCK", "OCR-D-SEG-LINE"], "output_file_grp": ["OCR-D-BIN-BLOCK", "OCR-D-BIN-LINE"], "steps": ["preprocessing/optimization/binarization"], "parameters": {"operation_level": {"type": "string", "enum": ["region", "line"], "default": "region", "description": "PAGE XML hierarchy level to operate on"}}}}}, "git": {"number_of_commits": "243", "last_commit": "Mon Aug 26 05:16:59 2019 +0200"}, "python": {"url": "https://github.com/OCR-D/ocrd_tesserocr", "name": "ocrd_tesserocr", "author": "Konstantin Baierer, Kay-Michael W\u00fcrzner, Robert Sachunsky", "author-email": "unixprog@gmail.com, wuerzner@gmail.com, sachunsky@informatik.uni-leipzig.de"}}, {"url": "https://github.com/mjenckel/LAYoutERkennung", "org_plus_name": "mjenckel/LAYoutERkennung", "name": "LAYoutERkennung", "files": {"ocrd-tool.json": "{\n  \"git_url\": \"https://github.com/syedsaqibbukhari/docanalysis\",\n  \"version\": \"0.0.1\",\n  \"tools\": {\n    \"ocrd-anybaseocr-tiseg\": {\n      \"executable\": \"ocrd-anybaseocr-tiseg\",\n      \"input_file_grp\": [\"OCR-D-IMG-BIN\"],\n      \"output_file_grp\": [\"OCR-D-SEG-TI-ANY\"],\n      \"categories\": [\"Layout analysis\"],\n      \"steps\": [\"layout/segmentation/text-image\"],\n      \"description\": \"separate text and non-text part with anyBaseOCR\",\n      \"parameters\": {\n      }\n    },\n    \"ocrd-anybaseocr-textline\": {\n      \"executable\": \"ocrd-anybaseocr-textline\",\n      \"input_file_grp\": [\"OCR-D-SEG-TI\"],\n      \"output_file_grp\": [\"OCR-D-SEG-LINE-ANY\"],\n      \"categories\": [\"Layout analysis\"],\n      \"steps\": [\"layout/segmentation/line\"],\n      \"description\": \"separate each text line\",\n      \"parameters\": {\n        \"minscale\":    {\"type\": \"number\", \"format\": \"float\", \"default\": 12.0, \"description\": \"minimum scale permitted\"},\n        \"maxlines\":    {\"type\": \"number\", \"format\": \"float\", \"default\": 300, \"description\": \"non-standard scaling of horizontal parameters\"},\n        \"scale\":       {\"type\": \"number\", \"format\": \"float\", \"default\": 0.0, \"description\": \"the basic scale of the document (roughly, xheight) 0=automatic\"},\n        \"hscale\":      {\"type\": \"number\", \"format\": \"float\", \"default\": 1.0, \"description\": \"non-standard scaling of horizontal parameters\"},\n        \"vscale\":      {\"type\": \"number\", \"format\": \"float\", \"default\": 1.7, \"description\": \"non-standard scaling of vertical parameters\"},\n        \"threshold\":   {\"type\": \"number\", \"format\": \"float\", \"default\": 0.2, \"description\": \"baseline threshold\"},\n        \"noise\":       {\"type\": \"number\", \"format\": \"integer\", \"default\": 8, \"description\": \"noise threshold for removing small components from lines\"},\n        \"usegauss\":    {\"type\": \"boolean\", \"default\": false, \"description\": \"use gaussian instead of uniform\"},\n        \"maxseps\":     {\"type\": \"number\", \"format\": \"integer\", \"default\": 2, \"description\": \"maximum black column separators\"},\n        \"sepwiden\":    {\"type\": \"number\", \"format\": \"integer\", \"default\": 10, \"description\": \"widen black separators (to account for warping)\"},\n        \"blackseps\":   {\"type\": \"boolean\", \"default\": false, \"description\": \"also check for black column separators\"},\n        \"maxcolseps\":  {\"type\": \"number\", \"format\": \"integer\", \"default\": 2, \"description\": \"maximum # whitespace column separators\"},\n        \"csminaspect\": {\"type\": \"number\", \"format\": \"float\", \"default\": 1.1, \"description\": \"minimum aspect ratio for column separators\"},\n        \"csminheight\": {\"type\": \"number\", \"format\": \"float\", \"default\": 6.5, \"description\": \"minimum column height (units=scale)\"},\n        \"pad\":         {\"type\": \"number\", \"format\": \"integer\", \"default\": 3, \"description\": \"padding for extracted lines\"},\n        \"expand\":      {\"type\": \"number\", \"format\": \"integer\", \"default\": 3, \"description\": \"expand mask for grayscale extraction\"},\n        \"parallel\":    {\"type\": \"number\", \"format\": \"integer\", \"default\": 0, \"description\": \"number of CPUs to use\"},\n        \"libpath\":     {\"type\": \"string\", \"default\": \".\", \"description\": \"Library Path for C Executables\"}\n      }\n    }\n  }\n}\n", "Dockerfile": null, "README.md": "# LAYoutERkennung\nDFKI Layout Detection for OCR-D\n\nTo run these samples, you have to follow the document preprocessing pipeline from the following repository mentioned below\n\nhttps://github.com/syedsaqibbukhari/docanalysis\n", "setup.py": "# -*- coding: utf-8 -*-\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='layout-analysis',\n    version='v0.0.1',\n    author=\"Syed Saqib Bukhari\",\n    author_email=\"Saqib.Bukhari@dfki.de, Mohammad_mohsin.reza@dfki.de\",\n    url=\"https://github.com/mjenckel/LAYoutERkennung\",\n    license='Apache License 2.0',\n    long_description=open('README.md').read(),\n    long_description_content_type='text/markdown',\n    install_requires=open('requirements.txt').read().split('\\n'),\n    packages=find_packages(exclude=[\"work_dir\", \"src\"]),\n    package_data={\n        '': ['*.json']\n    },\n    entry_points={\n        'console_scripts': [\n            'ocrd-anybaseocr-tiseg = ocrd_anybaseocr.cli.cli:ocrd_anybaseocr_tiseg',\n            'ocrd-anybaseocr-textline = ocrd_anybaseocr.cli.cli:ocrd_anybaseocr_textline'\n        ]\n    },\n)\n"}, "ocrd_tool": {"git_url": "https://github.com/syedsaqibbukhari/docanalysis", "version": "0.0.1", "tools": {"ocrd-anybaseocr-tiseg": {"executable": "ocrd-anybaseocr-tiseg", "input_file_grp": ["OCR-D-IMG-BIN"], "output_file_grp": ["OCR-D-SEG-TI-ANY"], "categories": ["Layout analysis"], "steps": ["layout/segmentation/text-image"], "description": "separate text and non-text part with anyBaseOCR", "parameters": {}}, "ocrd-anybaseocr-textline": {"executable": "ocrd-anybaseocr-textline", "input_file_grp": ["OCR-D-SEG-TI"], "output_file_grp": ["OCR-D-SEG-LINE-ANY"], "categories": ["Layout analysis"], "steps": ["layout/segmentation/line"], "description": "separate each text line", "parameters": {"minscale": {"type": "number", "format": "float", "default": 12.0, "description": "minimum scale permitted"}, "maxlines": {"type": "number", "format": "float", "default": 300, "description": "non-standard scaling of horizontal parameters"}, "scale": {"type": "number", "format": "float", "default": 0.0, "description": "the basic scale of the document (roughly, xheight) 0=automatic"}, "hscale": {"type": "number", "format": "float", "default": 1.0, "description": "non-standard scaling of horizontal parameters"}, "vscale": {"type": "number", "format": "float", "default": 1.7, "description": "non-standard scaling of vertical parameters"}, "threshold": {"type": "number", "format": "float", "default": 0.2, "description": "baseline threshold"}, "noise": {"type": "number", "format": "integer", "default": 8, "description": "noise threshold for removing small components from lines"}, "usegauss": {"type": "boolean", "default": false, "description": "use gaussian instead of uniform"}, "maxseps": {"type": "number", "format": "integer", "default": 2, "description": "maximum black column separators"}, "sepwiden": {"type": "number", "format": "integer", "default": 10, "description": "widen black separators (to account for warping)"}, "blackseps": {"type": "boolean", "default": false, "description": "also check for black column separators"}, "maxcolseps": {"type": "number", "format": "integer", "default": 2, "description": "maximum # whitespace column separators"}, "csminaspect": {"type": "number", "format": "float", "default": 1.1, "description": "minimum aspect ratio for column separators"}, "csminheight": {"type": "number", "format": "float", "default": 6.5, "description": "minimum column height (units=scale)"}, "pad": {"type": "number", "format": "integer", "default": 3, "description": "padding for extracted lines"}, "expand": {"type": "number", "format": "integer", "default": 3, "description": "expand mask for grayscale extraction"}, "parallel": {"type": "number", "format": "integer", "default": 0, "description": "number of CPUs to use"}, "libpath": {"type": "string", "default": ".", "description": "Library Path for C Executables"}}}}}, "git": {"number_of_commits": "33", "last_commit": "Wed Jul 31 11:29:50 2019 +0200"}, "python": {"url": "https://github.com/mjenckel/LAYoutERkennung", "name": "layout-analysis", "author": "Syed Saqib Bukhari", "author-email": "Saqib.Bukhari@dfki.de, Mohammad_mohsin.reza@dfki.de"}}, {"url": "https://github.com/ocr-d-modul-2-segmentierung/segmentation-runner", "org_plus_name": "ocr-d-modul-2-segmentierung/segmentation-runner", "name": "segmentation-runner", "files": {"ocrd-tool.json": null, "Dockerfile": null, "README.md": "# page-segmentation module for OCRd\n\n## Requirements\n\n- For GPU-Support: [CUDA](https://developer.nvidia.com/cuda-downloads) and [CUDNN](https://developer.nvidia.com/cudnn)\n- other requirements are installed via Makefile / pip, see `requirements.txt`\n  in repository root and in `page-segmentation` submodule.\n\n## Setup\n\n```bash\nmake dep\n# or\nmake dep-gpu\n```\n\nthen\n\n```sh\nmake install\n```\n\n## Running\n\nThe main script is `ocrd-pc-seg-process`. It takes two parameters: a `--model` for the\npixel classifier and an `--image`, which must be a binarized image. For example\nwith the included model:\n\n```\nocrd-pc-seg-process --pc_model model/narren_dta02_eval_normaldh_maskfix_03 \\\n    --image abel_leibmedicus_1699_0007.bin.png\n```\n\nThis creates a folder with the basename of the image (e.g. `abel_leibmedicus_1699_0007/`)\nwith line images in `segmentation/${basename}_${paragraph_nr}_paragraph` and\nPageXML in `segmentation/clip_${filename}.xml` (where `$filename` is the input\nfile name,`$basename` is `$filename` without extensions, `$paragraph_nr` is\nsuccessive ocropus pagagraph number).\n", "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nInstalls binaries:\n    - ocropus-gpageseg-with-coords\n    - ocrd-pc-seg-process\n    - ocrd-pc-seg-single\n\"\"\"\nimport codecs\n\nfrom setuptools import setup, find_packages\n\nsetup(\n    name='ocrd_pc_segmentation',\n    version='0.1.0',\n    description='pixel-classifier based page segmentation',\n    long_description=codecs.open('README.md', encoding='utf-8').read(),\n    long_description_content_type='text/markdown',\n    author='Alexander Gehrke, Christian Reul, Christoph Wick',\n    author_email='alexander.gehrke@uni-wuerzburg.de, christian.reul@uni-wuerzburg.de, christoph.wick@uni-wuerzburg.de',\n    url='https://github.com/ocr-d-modul-2-segmentierung/segmentation-runner',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    install_requires=open(\"requirements.txt\").read().split(),\n    extras_require={\n        'tf_cpu': ['page-segmentation[tf_cpu]>=0.0.1'],\n        'tf_gpu': ['page-segmentation[tf_gpu]>=0.0.1'],\n    },\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    entry_points={\n        'console_scripts': [\n            'ocrd-pc-seg-single=ocrd_pc_segmentation.pc_segmentation:main',\n            'ocrd-pc-seg-process=ocrd_pc_segmentation.seg_process:main',\n        ]\n    },\n    scripts=['ocrd_pc_segmentation/ocropus-gpageseg-with-coords'],\n)\n"}, "ocrd_tool": null, "git": {"number_of_commits": "3", "last_commit": "Fri Mar 29 16:48:09 2019 +0100"}, "python": {"url": "https://github.com/ocr-d-modul-2-segmentierung/segmentation-runner", "name": "ocrd_pc_segmentation", "author": "Alexander Gehrke, Christian Reul, Christoph Wick", "author-email": "alexander.gehrke@uni-wuerzburg.de, christian.reul@uni-wuerzburg.de, christoph.wick@uni-wuerzburg.de"}}, {"url": "https://github.com/ASVLeipzig/cor-asv-fst", "org_plus_name": "ASVLeipzig/cor-asv-fst", "name": "cor-asv-fst", "files": {"ocrd-tool.json": null, "Dockerfile": null, "README.md": "# cor-asv-fst\n    OCR post-correction with error/lexicon Finite State Transducers and\n    chararacter-level LSTM language models\n\n## Introduction\n\n\n## Installation\n\nRequired Ubuntu packages:\n\n* Python (``python`` or ``python3``)\n* pip (``python-pip`` or ``python3-pip``)\n* virtualenv (``python-virtualenv`` or ``python3-virtualenv``)\n\nCreate and activate a virtualenv as usual.\n\nTo install Python dependencies and this module, then do:\n```shell\nmake deps install\n```\nWhich is the equivalent of:\n```shell\npip install -r requirements.txt\npip install -e .\n```\n\nIn addition to the requirements listed in `requirements.txt`, the tool\nrequires the\n[pynini](http://www.opengrm.org/twiki/bin/view/GRM/Pynini)\nlibrary, which has to be installed from source.\n\n## Usage\n\nThe package has two user interfaces:\n\n### Command Line Interface\n\nThe package contains a suite of CLI tools to work with plaintext data (prefix:\n`cor-asv-fst-*`). The minimal working examples and data formats are described\nbelow. Additionally, each tool has further optional parameters - for a detailed\ndescription, call the tool with the `--help` option.\n\n#### `cor-asv-fst-train`\n\nTrain FST models. The basic invocation is as follows:\n\n```shell\ncor-asv-fst-train -l LEXICON_FILE -e ERROR_MODEL_FILE -t TRAINING_FILE\n```\n\nThis will create two transducers, which will be stored in `LEXICON_FILE` and\n`ERROR_MODEL_FILE`, respectively. As the training of the lexicon and the error\nmodel is done independently, any of them can be skipped by omitting the\nrespective parameter.\n\n`TRAINING_FILE` is a plain text file in tab-separated, two-column format\ncontaining a line of OCR-output and the corresponding ground truth line:\n\n```\n\u00bb Bergebt mir, da\u00df ih niht wei\u00df, wie\t\u00bbVergebt mir, da\u00df ich nicht wei\u00df, wie\naus dem (Gei\u017fte aller Nationen Mahrunq\taus dem Gei\u017fte aller Nationen Nahrung\nKann\u017ft Du mir die re<h\u00e9e Bahn nich\u00e9 zeigen ?\tKann\u017ft Du mir die rechte Bahn nicht zeigen?\nfrag zu bringen. \u2014\ttrag zu bringen. \u2014\n\u017fie ins irdij<he Leben hinein, Mit leichtem,\t\u017fie ins irdi\u017fche Leben hinein. Mit leichtem,\n```\n\nEach line is treated independently. Alternatively to the above, the training\ndata may also be supplied as two files:\n\n```shell\ncor-asv-fst-train -l LEXICON_FILE -e ERROR_MODEL_FILE -i INPUT_FILE -g GT_FILE\n```\n\nIn this variant, `INPUT_FILE` and `GT_FILE` are both in tab-separated,\ntwo-column format, in which the first column is the line ID and the second the\nline:\n\n```\n>=== INPUT_FILE ===<\nalexis_ruhe01_1852_0018_022     ih denke. Aber was die \u017felige Frau Geheimr\u00e4th1n\nalexis_ruhe01_1852_0035_019     \u201eDas fann ich niht, c\u2019esl absolument impos-\nalexis_ruhe01_1852_0087_027     rend. In dem Augenbli> war 1hr niht wohl zu\nalexis_ruhe01_1852_0099_012     \u00fcr die fle \u017fich \u017fchlugen.\u201c\nalexis_ruhe01_1852_0147_009     \u017follte. Nur \u00dcber die Familien, wo man \u017fie einf\u00fchren\n\n>=== GT_FILE ===<\nalexis_ruhe01_1852_0018_022     ich denke. Aber was die \u017felige Frau Geheimr\u00e4thin\nalexis_ruhe01_1852_0035_019     \u201eDas kann ich nicht, c'est absolument impos\u2014\nalexis_ruhe01_1852_0087_027     rend. Jn dem Augenblick war ihr nicht wohl zu\nalexis_ruhe01_1852_0099_012     f\u00fcr die \u017fie \u017fich \u017fchlugen.\u201c\nalexis_ruhe01_1852_0147_009     \u017follte. Nur \u00fcber die Familien, wo man \u017fie einf\u00fchren\n```\n\n#### `cor-asv-fst-process`\n\nThis tool applies a trained model to correct plaintext data on a line basis.\nThe basic invocation is:\n\n```shell\ncor-asv-fst-process -i INPUT_FILE -o OUTPUT_FILE -l LEXICON_FILE -e ERROR_MODEL_FILE (-m LM_FILE)\n```\n\n`INPUT_FILE` is in the same format as for the training procedure. `OUTPUT_FILE`\ncontains the post-correction results in the same format.\n\n`LM_FILE` is a `ocrd_keraslm` language model - if supplied, it is used for\nrescoring.\n\n#### `cor-asv-fst-evaluate`\n\nThis tool can be used to evaluate the post-correction results. The minimal\nworking invocation is:\n\n```shell\ncor-asv-fst-evaluate -i INPUT_FILE -o OUTPUT_FILE -g GT_FILE\n```\n\nAdditionally, the parameter `-M` can be used to select the evaluation measure\n(`Levenshtein` by default). The files should be in the same two-column format\nas described above.\n\n### [OCR-D processor](https://github.com/OCR-D/core) interface `ocrd-cor-asv-fst-process`\n\nTo be used with [PageXML](https://www.primaresearch.org/tools/PAGELibraries)\ndocuments in an [OCR-D](https://github.com/OCR-D/spec/) annotation workflow.\nInput could be anything with a textual annotation (`TextEquiv` on the given\n`textequiv_level`).\n\n...\n\n```json\n  \"tools\": {\n    \"cor-asv-fst-process\": {\n      \"executable\": \"cor-asv-fst-process\",\n      \"categories\": [\n        \"Text recognition and optimization\"\n      ],\n      \"steps\": [\n        \"recognition/post-correction\"\n      ],\n      \"description\": \"Improve text annotation by FST error and lexicon model with character-level LSTM language model\",\n      \"input_file_grp\": [\n        \"OCR-D-OCR-TESS\",\n        \"OCR-D-OCR-KRAK\",\n        \"OCR-D-OCR-OCRO\",\n        \"OCR-D-OCR-CALA\",\n        \"OCR-D-OCR-ANY\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-COR-ASV\"\n      ],\n      \"parameters\": {\n        \"keraslm_file\": {\n          \"type\": \"string\",\n          \"format\": \"uri\",\n          \"content-type\": \"application/x-hdf;subtype=bag\",\n          \"description\": \"path of h5py weight/config file for language model trained with keraslm\",\n          \"required\": true,\n          \"cacheable\": true\n        },\n        \"errorfst_file\": {\n          \"type\": \"string\",\n          \"format\": \"uri\",\n          \"content-type\": \"application/vnd.openfst\",\n          \"description\": \"path of FST file for error model\",\n          \"required\": true,\n          \"cacheable\": true\n        },\n        \"lexiconfst_file\": {\n          \"type\": \"string\",\n          \"format\": \"uri\",\n          \"content-type\": \"application/vnd.openfst\",\n          \"description\": \"path of FST file for lexicon model\",\n          \"required\": true,\n          \"cacheable\": true\n        },\n        \"textequiv_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"word\", \"glyph\"],\n          \"default\": \"glyph\",\n          \"description\": \"PAGE XML hierarchy level to read TextEquiv input on (output will always be word level)\"\n        },\n        \"beam_width\": {\n          \"type\": \"number\",\n          \"format\": \"integer\",\n          \"description\": \"maximum number of best partial paths to consider during beam search in language modelling\",\n          \"default\": 100\n        },\n        \"lm_weight\": {\n          \"type\": \"number\",\n          \"format\": \"float\",\n          \"description\": \"share of the LM scores over the FST output confidences\",\n          \"default\": 0.5\n        }\n      }\n    }\n  }\n```\n\n...\n\n## Testing\n\n...\n", "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nInstalls:\n    - cor-asv-fst-train\n    - cor-asv-fst-process\n    - cor-asv-fst-evaluate\n    - ocrd-cor-asv-fst-process\n\"\"\"\nimport codecs\n\nfrom setuptools import setup, find_packages\n\ninstall_requires = open('requirements.txt').read().split('\\n')\n\nwith codecs.open('README.md', encoding='utf-8') as f:\n    README = f.read()\n\nsetup(\n    name='ocrd_cor_asv_fst',\n    version='0.2.0',\n    description='OCR post-correction with error/lexicon Finite State '\n                'Transducers and character-level LSTMs',\n    long_description=README,\n    author='Maciej Sumalvico, Robert Sachunsky',\n    author_email='sumalvico@informatik.uni-leipzig.de, '\n                 'sachunsky@informatik.uni-leipzig.de',\n    url='https://github.com/ASVLeipzig/cor-asv-fst',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    install_requires=install_requires,\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    test_suite='tests',\n    entry_points={\n        'console_scripts': [\n            'cor-asv-fst-train=ocrd_cor_asv_fst.scripts.train:main',\n            'cor-asv-fst-process=ocrd_cor_asv_fst.scripts.process:main',\n            'cor-asv-fst-evaluate=ocrd_cor_asv_fst.scripts.evaluate:main',\n            'ocrd-cor-asv-fst-process=ocrd_cor_asv_fst.wrapper.cli:ocrd_cor_asv_fst',\n        ]\n    }\n)\n"}, "ocrd_tool": null, "git": {"number_of_commits": "1", "last_commit": "Tue Jul 23 17:00:16 2019 +0200"}, "python": {"url": "https://github.com/ASVLeipzig/cor-asv-fst", "name": "ocrd_cor_asv_fst", "author": "Maciej Sumalvico, Robert Sachunsky", "author-email": "sumalvico@informatik.uni-leipzig.de, sachunsky@informatik.uni-leipzig.de"}}, {"url": "https://github.com/ASVLeipzig/cor-asv-ann", "org_plus_name": "ASVLeipzig/cor-asv-ann", "name": "cor-asv-ann", "files": {"ocrd-tool.json": null, "Dockerfile": null, "README.md": "# cor-asv-ann\n    OCR post-correction with encoder-attention-decoder LSTMs\n\n## Introduction\n\nThis is a tool for automatic OCR _post-correction_ (reducing optical character recognition errors) with recurrent neural networks. It uses sequence-to-sequence transduction on the _character level_ with a model architecture akin to neural machine translation, i.e. a stacked **encoder-decoder** network with attention mechanism. \n\nThe **attention model** always applies to full lines (in a _global_ configuration), and uses a linear _additive_ alignment model. (This transfers information between the encoder and decoder hidden layer states, and calculates a _soft alignment_ between input and output characters. It is imperative for character-level processing, because with a simple final-initial transfer, models tend to start \"forgetting\" the input altogether at some point in the line and behave like unconditional LM generators.)\n\n...FIXME: mention: \n- stacked architecture (with bidirectional bottom and attentional top), configurable depth/width\n- weight tying\n- underspecification and gap\n- confidence input and alternative input\n- CPU/GPU option\n- incremental training, LM transfer, shallow transfer\n- evaluation (CER, PPL)\n\n### Processing PAGE annotations\n\nWhen applied on PAGE-XML (as OCR-D workspace processor), this component also allows processing below the `TextLine` hierarchy level, i.e. on `Word` or `Glyph` level. For that it uses the soft alignment scores to calculate an optimal hard alignment path for characters, and thereby distributes the transduction onto the lower level elements (keeping their coordinates and other meta-data), while changing Word segmentation if necessary.\n\n...\n\n### Architecture\n\n...FIXME: show!\n\n### Input with confidence and/or alternatives\n\n...FIXME: explain!\n\n### Multi-OCR input\n\nnot yet!\n\n### Modes\n\nWhile the _encoder_ can always be run in parallel over a batch of lines and by passing the full sequence of characters in one tensor (padded to the longest line in the batch), which is very efficient with Keras backends like Tensorflow, a **beam-search** _decoder_ requires passing initial/final states character-by-character, with parallelism employed to capture multiple history hypotheses of a single line. However, one can also **greedily** use the best output only for each position (without beam search). And in doing so, another option is to feed back the softmax output directly into the decoder input instead of its argmax unit vector. This effectively passes the full probability distribution from state to state, which (not very surprisingly) can increase correction accuracy quite a lot \u2013 it can get as good as a medium-sized beam search results. This latter option also allows to run in parallel again, which is also much faster \u2013 consuming up to ten times less CPU time.\n\nThererfore, the backend function `lib.Sequence2Sequence.correct_lines` can operate the encoder-decoder network in either of the following modes:\n\n#### _fast_\n\nDecode greedily, but feeding back the full softmax distribution in batch mode.\n\n#### _greedy_\n\nDecode greedily, but feeding back the argmax unit vectors for each line separately.\n\n#### _default_\n\nDecode beamed, feeding back the argmax unit vectors for the best history/output hypotheses of each line. More specifically:\n\n> Start decoder with start-of-sequence, then keep decoding until\n> end-of-sequence is found or output length is way off, repeatedly.\n> Decode by using the best predicted output characters and several next-best\n> alternatives (up to some degradation threshold) as next input.\n> Follow-up on the N best overall candidates (estimated by accumulated\n> score, normalized by length and prospective cost), i.e. do A*-like\n> breadth-first search, with N equal `batch_size`.\n> Pass decoder initial/final states from character to character,\n> for each candidate respectively.\n> Reserve 1 candidate per iteration for running through `source_seq`\n> (as a rejection fallback) to ensure that path does not fall off the\n> beam and at least one solution can be found within the search limits.\n\n### Evaluation\n\nText lines can be compared (by aligning and computing a distance under some metric) across multiple inputs. (This would typically be GT and OCR vs post-correction.) This can be done both on plain text files (`cor-asv-ann-eval`) and PAGE-XML annotations (`ocrd-cor-asv-ann-evaluate`).\n\nThere are a number of distance metrics available:\n- `Levenshtein`: simple unweighted edit distance (fastest, standard)\n- `combining-e-umlauts`: like the former, but umlauts with combining letter e get smaller distance to precomposed umlauts (and vice versa), as in \"Wu\u0364\u017fte\" (as opposed to \"W\u00fc\u017fte\")\n- `historic_latin`: like the former, but with additional exceptions (i.e. zero distances) for certain (isolated) character confusions \u2013 roughly the difference between GT level 1 and 2\n- `NFC`: like `Levenshtein`, but apply Unicode normal form with canonical composition before (i.e. less than `historic_latin`)\n- `NFKC`: like `Levenshtein`, but apply Unicode normal form with compatibility composition before (i.e. more than `historic_latin`)\n\n\n## Installation\n\nRequired Ubuntu packages:\n\n* Python (``python`` or ``python3``)\n* pip (``python-pip`` or ``python3-pip``)\n* virtualenv (``python-virtualenv`` or ``python3-virtualenv``)\n\nCreate and activate a virtualenv as usual.\n\nTo install Python dependencies and this module, then do:\n```shell\nmake deps install\n```\nWhich is the equivalent of:\n```shell\npip install -r requirements.txt\npip install -e .\n```\n\n## Usage\n\nThis packages has the following user interfaces:\n\n### command line interface `cor-asv-ann-train`\n\nTo be used with string arguments and plain-text files.\n\n...\n\n### command line interface `cor-asv-ann-eval`\n\nTo be used with string arguments and plain-text files.\n\n...\n\n### command line interface `cor-asv-ann-repl`\n\ninteractive\n\n...\n\n### [OCR-D processor](https://github.com/OCR-D/core) interface `ocrd-cor-asv-ann-process`\n\nTo be used with [PageXML](https://www.primaresearch.org/tools/PAGELibraries) documents in an [OCR-D](https://github.com/OCR-D/spec/) annotation workflow. Input could be anything with a textual annotation (`TextEquiv` on the given `textequiv_level`). \n\n...\n\n```json\n    \"ocrd-cor-asv-ann-process\": {\n      \"executable\": \"ocrd-cor-asv-ann-process\",\n      \"categories\": [\n        \"Text recognition and optimization\"\n      ],\n      \"steps\": [\n        \"recognition/post-correction\"\n      ],\n      \"description\": \"Improve text annotation by character-level encoder-attention-decoder ANN model\",\n      \"input_file_grp\": [\n        \"OCR-D-OCR-TESS\",\n        \"OCR-D-OCR-KRAK\",\n        \"OCR-D-OCR-OCRO\",\n        \"OCR-D-OCR-CALA\",\n        \"OCR-D-OCR-ANY\"\n      ],\n      \"output_file_grp\": [\n        \"OCR-D-COR-ASV\"\n      ],\n      \"parameters\": {\n        \"model_file\": {\n          \"type\": \"string\",\n          \"format\": \"uri\",\n          \"content-type\": \"application/x-hdf;subtype=bag\",\n          \"description\": \"path of h5py weight/config file for model trained with cor-asv-ann-train\",\n          \"required\": true,\n          \"cacheable\": true\n        },\n        \"textequiv_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"line\", \"word\", \"glyph\"],\n          \"default\": \"glyph\",\n          \"description\": \"PAGE XML hierarchy level to read/write TextEquiv input/output on\"\n        }\n      }\n    }\n```\n\n...\n\n### [OCR-D processor](https://github.com/OCR-D/core) interface `ocrd-cor-asv-ann-evaluate`\n\nTo be used with [PageXML](https://www.primaresearch.org/tools/PAGELibraries) documents in an [OCR-D](https://github.com/OCR-D/spec/) annotation workflow. Inputs could be anything with a textual annotation (`TextEquiv` on the line level), but at least 2. The first in the list of input file groups will be regarded as reference/GT.\n\n...\n\n```json\n    \"ocrd-cor-asv-ann-evaluate\": {\n      \"executable\": \"ocrd-cor-asv-ann-evaluate\",\n      \"categories\": [\n        \"Text recognition and optimization\"\n      ],\n      \"steps\": [\n        \"recognition/evaluation\"\n      ],\n      \"description\": \"Align different textline annotations and compute distance\",\n      \"parameters\": {\n        \"metric\": {\n          \"type\": \"string\",\n          \"enum\": [\"Levenshtein\", \"combining-e-umlauts\", \"NFC\", \"NFKC\", \"historic_latin\"],\n          \"default\": \"Levenshtein\",\n          \"description\": \"Distance metric to calculate and aggregate\"\n        }\n      }\n    }\n```\n\n...\n\n## Testing\n\nnot yet!\n...\n", "setup.py": "# -*- coding: utf-8 -*-\n\"\"\"\nInstalls:\n    - cor-asv-ann-train\n    - cor-asv-ann-eval\n    - cor-asv-ann-repl\n    - ocrd-cor-asv-ann-process\n    - ocrd-cor-asv-ann-evaluate\n\"\"\"\nimport codecs\n\nfrom setuptools import setup, find_packages\n\ninstall_requires = open('requirements.txt').read().split('\\n')\n\nwith codecs.open('README.md', encoding='utf-8') as f:\n    README = f.read()\n\nsetup(\n    name='ocrd_cor_asv_ann',\n    version='0.1.1',\n    description='sequence-to-sequence translator for noisy channel error correction',\n    long_description=README,\n    author='Robert Sachunsky',\n    author_email='sachunsky@informatik.uni-leipzig.de',\n    url='https://github.com/ASVLeipzig/cor-asv-ann',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    install_requires=install_requires,\n    package_data={\n        '': ['*.json', '*.yml', '*.yaml'],\n    },\n    entry_points={\n        'console_scripts': [\n            'cor-asv-ann-train=ocrd_cor_asv_ann.scripts.train:cli',\n            'cor-asv-ann-eval=ocrd_cor_asv_ann.scripts.eval:cli',\n            'cor-asv-ann-repl=ocrd_cor_asv_ann.scripts.repl:cli',\n            'ocrd-cor-asv-ann-process=ocrd_cor_asv_ann.wrapper.cli:ocrd_cor_asv_ann_process',\n            'ocrd-cor-asv-ann-evaluate=ocrd_cor_asv_ann.wrapper.cli:ocrd_cor_asv_ann_evaluate',\n        ]\n    },\n)\n"}, "ocrd_tool": null, "git": {"number_of_commits": "1", "last_commit": "Fri Jul 19 23:53:14 2019 +0200"}, "python": {"url": "https://github.com/ASVLeipzig/cor-asv-ann", "name": "ocrd_cor_asv_ann", "author": "Robert Sachunsky", "author-email": "sachunsky@informatik.uni-leipzig.de"}}, {"url": "https://github.com/cisocrgroup/ocrd-postcorrection", "org_plus_name": "cisocrgroup/ocrd-postcorrection", "name": "ocrd-postcorrection", "files": {"ocrd-tool.json": null, "Dockerfile": "FROM ocrd/core\nMAINTAINER Florian Fink <finkf@cis.lmu.de>\nENV OCRD_VERSION \"ocrd-0.1\"\nENV PROFILER_GIT https://github.com/cisocrgroup/Profiler\nENV LC_ALL C.UTF-8\nENV LANG C.UTF-8\n\nVOLUME [\"/data\"]\n# update\nRUN apt-get update && \\\n    apt-get install -y git cmake g++ libxerces-c-dev libcppunit-dev openjdk-8-jre\n\nENV VERSION \"2018-06-06\"\n# install profiler\nRUN mkdir /src && \\\n    cd /src && \\\n    git clone -b ocrd ${PROFILER_GIT} && \\\n    cd Profiler && mkdir build && cd build && \\\n    cmake -DCMAKE_BUILD_TYPE=release .. && \\\n    make -j 4 profiler && \\\n    mkdir /apps && \\\n    cp bin/profiler /apps/ && \\\n    cd / && \\\n\t\trm -rf /src/Profiler\nCOPY target/${OCRD_VERSION}-cli.jar /apps/\n\nENTRYPOINT [\"/bin/sh\", \"-c\"]\n#COPY target/${OCRD_VERSION}.war /usr/local/tomcat/webapps\n#COPY tomcat-users.xml ${CATALINA_HOME}/conf/tomcat-users.xml\n#COPY context.xml ${CATALINA_HOME}/webapps/manager/META-INF/context.xml\n#COPY context.xml ${CATALINA_HOME}/webapps/host-manager/META-INF/context.xml\n", "README.md": "![build status](https://travis-ci.org/cisocrgroup/ocrd-postcorrection.svg?branch=dev)\nOCRD REST API\n====================\n\n\nEclipse/Maven project for OCRD Application Server REST API & UIF\n\n## prerequisites\n- JDK8 or better\n- Maven 3\n- Eclipse 4.X or better (installed maven plugin & e.g. Spring STS)\n\n\n## build, run & dev-steps\n\n### import to eclipse\n1. clone repo to your local machine\n2. Open Eclipse\n3. File->Import->Maven->existing Maven project\n4. Run from new projects's context menu Maven->Update project\n5. New Java code from RAML is generated in /target/generated-sources/raml-jaxrs\n\n\n### run local jetty dev-server\n\n#### steps:\n- run eclipse project on server: `RunLocalJetty.java`\n- Point your browser to http://localhost:8181\n    * `/` shows html & js pages which reside in `src/webapp`\n    * `/api/` points to all api endpoints\n\n\n#### API documentation:\n- install raml2html module (https://github.com/raml2html/raml2html)\n- to generate use: raml2html api.raml > api.html\n\n\n\nOCRD WEB APP\n====================\n\n- sources in webapp-src folder\n\n### contents\nall source files which are needed to build the webapp (e.g. backbone js code & HTML markup code)\n\n### build\nuse build scripts to create a build. The build-script shall sync the build to `src/webapp`\n", "setup.py": null}, "ocrd_tool": null, "git": {"number_of_commits": "1", "last_commit": "Wed Jul 11 10:05:04 2018 +0200"}, "python": {"url": "", "name": "", "author": "", "author-email": ""}}, {"url": "https://github.com/seuretm/ocrd_typegroups_classifier", "org_plus_name": "seuretm/ocrd_typegroups_classifier", "name": "ocrd_typegroups_classifier", "files": {"ocrd-tool.json": "{\n  \"version\": \"0.0.1\",\n  \"git_url\": \"https://github.com/seuretm/ocrd_typegroups_classifier\",\n  \"tools\": {\n    \"ocrd-typegroups-classifier\": {\n      \"executable\": \"ocrd-typegroups-classifier\",\n      \"description\": \"Classification of 15th century type groups\",\n      \"categories\": [\n        \"Text recognition and optimization\"\n      ],\n      \"steps\": [\n        \"recognition/font-identification\"\n      ],\n      \"parameters\": {\n        \"network\": {\n          \"description\": \"The file name of the neural network to use, including sufficient path information\",\n          \"type\": \"string\",\n          \"required\": true\n        },\n        \"stride\": {\n          \"description\": \"Stride applied to the CNN on the image. Should be between 1 and 224. Smaller values increase the computation time.\",\n          \"type\": \"number\",\n          \"format\": \"integer\",\n          \"default\": 112\n        }\n      }\n    }\n  }\n}\n", "Dockerfile": null, "README.md": "# ocrd_typegroups_classifier\n\n> Typegroups classifier for OCR\n\n## Quick setup\n\nIf needed, create a virtual environment for Python 3 (it was tested\nsuccessfully with Python 3.7), activate it, and install ocrd.\n\n```sh\nvirtualenv -p python3 ocrd-venv3\nsource ocrd-venv3/bin/activate\npip3 install ocrd\n```\n\nEnter in the folder containing the tool:\n```cd ocrd_typegroups_classifier/```\n\nInstall the module and its dependencies\n\n```\nmake install\nmake deps\n```\n\nFinally, run the test:\n\n```\nsh test/test.sh\n```\n\n** Important: ** The test makes sure that the system does work. For\nspeed reasons, a very small neural network is used and applied only to\nthe top-left corner of the image, therefore the quality of the results\nwill be of poor quality.\n\n## Models\n\nThe model classifier-1.tgc is based on a ResNet-18, with less neurons\nper layer than the usual model. It was briefly trained on 12 classes:\nAdornment, Antiqua, Bastarda, Book covers and other irrelevant data,\nEmpty Pages, Fraktur, Griechisch, Hebr\u00e4isch, Kursiv, Rotunda, Textura,\nand Woodcuts - Engravings.\n\n## Heatmap Generation ##\nGiven a trained model, it is possible to produce heatmaps corresponding\nto classification results. Syntax:\n\n```\npython3 tools/heatmap.py ocrd_typegroups_classifier/models/classifier.tgc sample.jpg out\n```", "setup.py": "# -*- coding: utf-8 -*-\nimport codecs\n\nfrom setuptools import setup, find_packages\n\nwith codecs.open('README.md', encoding='utf-8') as f:\n    README = f.read()\n\nsetup(\n    name='ocrd_typegroups_classifier',\n    version='0.0.1',\n    description='Typegroups classifier for OCR',\n    long_description=README,\n    long_description_content_type='text/markdown',\n    author='Matthias Seuret, Konstantin Baierer',\n    author_email='seuretm@users.noreply.github.com',\n    url='https://github.com/seuretm/ocrd_typegroups_classifier',\n    license='Apache License 2.0',\n    packages=find_packages(exclude=('tests', 'docs')),\n    include_package_data=True,\n    install_requires=[\n        'click',\n        'ocrd >= 1.0.0b7',\n        'pandas',\n        'Pillow >= 5.3.0',\n        'scikit-image',\n        'torch',\n        'torchvision',\n    ],\n    package_data={\n        '': ['*.json', '*.tgc'],\n    },\n    entry_points={\n        'console_scripts': [\n            'typegroups-classifier=ocrd_typegroups_classifier.cli.simple:cli',\n            'ocrd-typegroups-classifier=ocrd_typegroups_classifier.cli.ocrd_cli:cli',\n        ]\n    },\n)\n"}, "ocrd_tool": {"version": "0.0.1", "git_url": "https://github.com/seuretm/ocrd_typegroups_classifier", "tools": {"ocrd-typegroups-classifier": {"executable": "ocrd-typegroups-classifier", "description": "Classification of 15th century type groups", "categories": ["Text recognition and optimization"], "steps": ["recognition/font-identification"], "parameters": {"network": {"description": "The file name of the neural network to use, including sufficient path information", "type": "string", "required": true}, "stride": {"description": "Stride applied to the CNN on the image. Should be between 1 and 224. Smaller values increase the computation time.", "type": "number", "format": "integer", "default": 112}}}}}, "git": {"number_of_commits": "47", "last_commit": "Tue Apr 30 16:09:15 2019 +0200"}, "python": {"url": "https://github.com/seuretm/ocrd_typegroups_classifier", "name": "ocrd_typegroups_classifier", "author": "Matthias Seuret, Konstantin Baierer", "author-email": "seuretm@users.noreply.github.com"}}]
